---
layout: post
title: "Teaching MCP Through an RPG: Metacon2"
subtitle: "Building an educational game where players learn protocol concepts by exploring a virtual village"
date: 2026-01-10
---

How do you teach something as abstract as the Model Context Protocol? Documentation helps, but understanding really clicks through experience. MCP Quest (Metacon2) turns protocol concepts into a Pokémon-style RPG where you learn by exploring, talking to NPCs, and completing challenges.

## The Educational Design

The game teaches three core concepts: Servers (programs that provide tools and resources), Clients (applications that connect and request capabilities), and JSON-RPC Protocol (the structured message format connecting them).

Each concept gets its own NPC. The Server Keeper explains how servers expose functionality. The Client Sage describes how clients discover and use capabilities. The Protocol Master teaches the message structure that enables communication.

A Guide NPC tracks your progress and gates advancement—you can't proceed until you've learned all three concepts. This prevents skipping content and ensures sequential understanding.

## The RPG-JS Foundation

I built on RPG-JS, an open-source JavaScript RPG engine that handles the complex parts: sprite rendering, tile-based movement, event systems, collision detection. My job was layering educational content on top.

The project structure follows RPG-JS conventions: events in TypeScript files, maps in TMX format, UI in Vue 3 components. NPCs use decorators (`@EventData`) that auto-bind to map objects, keeping code modular and extensible.

## The Progress Journal

Press J to open a Pokédex-style journal showing your learning progress. Each concept gets a card: learned (full details visible) or unknown (silhouette and question marks).

A progress bar shows 0-100% completion across the three concepts. The journal updates reactively—learn a concept from an NPC, and the journal reflects it immediately without page refreshes.

The styling is intentionally nostalgic: dark purple background, gold accents, retro pixel feel. Educational games work better when they feel like games rather than tutorials.

## The Sorting Mini-Game

After learning all three concepts, press M to open the Message Sorting challenge. Six JSON-RPC components appear: `method`, `params`, `result`, `error`, `id`, `jsonrpc`.

Your task: drag each component to the correct zone—REQUEST or RESPONSE. `method` and `params` belong in requests. `result` and `error` belong in responses. `id` and `jsonrpc` are valid in both.

Get at least 5/6 correct, and you've proven you understand the protocol structure. The mini-game transforms passive learning (hearing about concepts) into active demonstration (applying knowledge).

## The Technical Challenges

The biggest challenge was map loading. The working V1 map uses Base64 tile encoding (RPG-JS default). My V2 map, designed in Tiled, exports as CSV for human readability. This encoding mismatch causes a black screen.

The fix should be simple: ensure consistent encoding and proper object layer attributes. But debugging map issues in game engines is notoriously frustrating—silent failures, cryptic error states, multiple interacting systems.

V1 works well enough for validation. V2 is blocked by what's probably a one-line configuration issue. Such is game development.

## Player State Management

RPG-JS provides player hooks for managing game state. Each player connection tracks variables:

- `CONCEPTS_LEARNED`: counter from 0 to 3
- `LEARNED_SERVER/CLIENT/PROTOCOL`: boolean flags for each concept
- `GATE_UNLOCKED`: progression blocker
- `MINIGAME_COMPLETE`: quest completion flag

These variables sync across client and server, enabling reactive UI updates. Change a variable in NPC dialogue, and the journal reflects it immediately.

## The Extensibility Story

The architecture supports expansion to additional zones. Add new maps to the world definition, new NPCs following the same pattern, new variables tracking cross-zone progress. Portal events enable map transitions with prerequisite checking.

I could add zones for advanced concepts: tool schema validation, error handling patterns, streaming responses. Each zone would have its own NPCs, challenges, and rewards. The structure scales.

## Why Games for Education?

Abstract concepts benefit from embodiment. When you talk to a Server Keeper NPC, you're not just reading a definition—you're interacting with a character who represents the concept. The spatial memory of "I learned about clients from that sage by the fountain" is stickier than "I read it in paragraph 3."

The gating mechanism prevents overwhelm. You can't rush to the end; you must engage with each concept. The mini-game prevents passive consumption; you must demonstrate understanding.

Is it the most efficient way to learn MCP? Probably not. But efficiency isn't everything. Engagement matters, and games are engaging in ways that documentation isn't.

This project sits at an intersection I find compelling: technical education that respects how people actually learn. Not everyone wants to read specs. Some people want to explore a village and talk to an NPC who explains, in character, why servers and clients need a common protocol. That's valid too.
